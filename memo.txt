설치
git-scm

초기 이름, 이메일 등록(전역)
git config --global user.name "name"
git config --global user.email "email"



로컬 저장소

특정 폴더를 Git저장소로 등록하려면, Git 저장소를 사용할 폴더로 이동 후
git init

폴더 작업트리와 인덱스 상태를 확인하려면
git status

인덱스에 등록하려면(스테이지에 등록하려면)
개별 파일, 여러 파일
git add <file1> <file2> ...
하위 모든 파일
git add .

커밋
git commit -m "comment"

저장소 변경 이력 조회
git log



내 로컬 저장소에서 변경 이력을 원격저장소에 공유하려면 먼저 원격 저장소에 업로드해야 한다.
push를 실행하면 원격 저장소에 내 변경 이력이 업로드되어 원격 저장소와 로컬 저장소가 동일한 상태가 된다.

누군가의 변경이력이 적용된 원격 저장소가 있으면 복제해와서 내 PC에서 직접 작업할 수 있다.
변경 이력도 함께 로컬 저장소에 복제되어와서 원격 저장소와 똑같이 이력을 참조하고 커밋을 진행할 수 있다.

이미 가져온 상태라고 가정하고 다른 사람이 원격 저장소에 올려놓은(push) 변경 내용을 내 로컬 저장소에도 적용(pull)할 필요가 있다.



원격 저장소 
github

원격 저장소에 로컬 저장소의 이력을 push
원격 저장소의 주소를 기록해두면 push 할 때마다 긴 원격 저장소 주소를 입력할 필요가 없다. 
origin 이라는 이름으로 원격 저장소를 등록하고 push 하자

원격 저장소를 추가(등록)
git remote add <name> <url>
git remote add origin https://github.com/HyungchulCha/git_tutorial.git

원격 저장소에 push
git push -u <repository> <refspec> ...
-u : 한번 -u를 지정하면 이후에는 브랜치명 지정을 생략할 수 있다. 단, 비어있는 원격저장소에 최초로 push할 때는 원격 저장소명과 브랜치명을 생략할 수 없다.
repository : 현재는 origin 으로 등록했으므로 origin
refspec : push 할 브랜치를 지정
git push -u origin master



clone
git clone <repository> <directory>
git clone https://github.com/HyungchulCha/git_tutorial.git git_tutorial_clone
username: <name>
password: <password>

복제한 저장소에서 수정했다고 가정
git add memo.txt
git commit -m "comment"

복제한 저장소에서 원격 저장소를 push할 때는 origin master를 생략할 수 있다.
git push



pull
원격 저장소에서 원래 폴더로 최신 변경 내용을 가져와보자
git pull <repository> <refspec> ...
만약 저장소명이 생략되면 origin의 이름으로 등록되어 있는 저장소 밑에 pull을 수행하게 된다.
git pull origin master



merge
내가 pull 을 실행한 후 다른 사람이 push 를 하여 원격 저장소를 업데이트 해버린 경우에는 내 push 요청이 거부
merge라는 작업을 진행하여 다른 사람의 업데이트 이력을 내 저장소에도 갱신 해야한다.
병합 기능은 Git 에서 변경한 부분을 자동으로 통합해 주는 기능입니다. 그러나 경우에 따라 자동으로 병합할 수 없는 경우도 있습니다.
모든 충돌 부분을 수정한 후에, 다시 커밋을 수행하면 됩니다.



작업순서 : add - commit - pull - merge - add - commit - push






Branch



master Branch
저장소를 처음 만들면, Git은 바로 'master'라는 이름의 브랜치를 만들어 둡니다.
'master'가 아닌 또 다른 새로운 브랜치를 만들어서 사용 (checkout)

통합 브랜치 (Integration Branch)
통합 브랜치란 언제든지 배포할 수 있는 버전을 만들 수 있어야 하는 브랜치 입니다.
안정적인 상태(어플리케이션의 모든 기능이 정상적으로 동작하는 상태)를 유지하는 것이 중요합니다.
어떤 문제가 발견되어 그 문제(버그)를 수정한다던지 새로운 기능을 추가해야 한다던지 해야할 때, 바로 '토픽 브랜치(Topic branch)'를 만들 수 있습니다.
일반적으로 저장소를 처음 만들었을 때에 생기는 'master' 브랜치를 통합 브랜치로 사용합니다.

토픽 브랜치(Topic Branch)
토픽 브랜치에서 특정 작업이 완료되면 다시 통합 브랜치에 병합하는 방식으로 진행됩니다. 이러한 토픽 브랜치는 '피처 브랜치(Feature branch)' 라고 부르기도 합니다.



브랜치 전환하기
처음에 Git을 설치하게 되면 'master' 브랜치가 선택되어 있죠. 현재 선택된 브랜치가 아닌 다른 브랜치에서 작업하고 싶을 때에는, '체크아웃(checkout)' 명령어를 실행하여 원하는 브랜치로 전환할 수 있습니다.
체크아웃을 실행하면, 우선 브랜치 안에 있는 마지막 커밋 내용이 작업 트리에 펼쳐집니다.

HEAD
'HEAD' 란 현재 사용 중인 브랜치의 선두 부분을 나타내는 이름입니다. 기본적으로는 'master'의 선두 부분을 나타냅니다.

stash
커밋하지 않은 변경 내용이나 새롭게 추가한 파일이 인덱스와 작업 트리에 남아 있는 채로 다른 브랜치로 전환(checkout)하면, 그 변경 내용은 기존 브랜치가 아닌 전환된 브랜치에서 커밋할 수 있습니다.
단, 커밋 가능한 변경 내용 중에 전환된 브랜치에서도 한 차례 변경이 되어 있는 경우에는 체크아웃에 실패할 수 있습니다. 이 경우 이전 브랜치에서 커밋하지 않은 변경 내용을 커밋하거나, stash 를 이용해 일시적으로 변경 내용을 다른 곳에 저장하여 충돌을 피하게 한 뒤 체크아웃을 해야 합니다.
stash 란, 파일의 변경 내용을 일시적으로 기록해두는 영역입니다. stash 를 사용하여 작업 트리와 인덱스 내에서 아직 커밋하지 않은 변경을 일시적으로 저장해 둘 수 있습니다. 이 stash 에 저장된 변경 내용은 나중에 다시 불러와 원래의 브랜치나 다른 브랜치에 커밋할 수 있습니다.



브랜치 통합하기
브랜치 통합에는 merge를 사용하는 방법과 'rebase'를 사용하는 방법의 2가지 종류가 있습니다. 어느 쪽을 사용하느냐에 따라 통합 후의 브랜치의 이력이 크게 달라집니다.

merge
merge 를 사용하면, 여러 개의 브랜치를 하나로 모을 수 있습니다.

fast-forward(빨리 감기) 병합
A 브랜치를 'master' 브랜치로 병합할 때, 'master' 브랜치의 상태가 이전부터 변경되어 있지 않으면 매우 쉽게 병합할 수 있습니다. 

non fast-forward 병합 (의도적)
브랜치가 그대로 남기 때문에 그 브랜치로 실행한 작업 확인 및 브랜치 관리 면에서 더 유용할 수 있습니다.

merge commit(병합 커밋)
'master' 브랜치에 여러 가지 변경 사항이 적용되는 경우

rebase
'non fast-forward 병합' 방식으로 진행되는 시나리오(가정)
A 브랜치를 'master' 브랜치에 rebase 하면, A 브랜치의 이력이 'master' 브랜치 뒤(후)로 이동하게 됩니다. 그 때문에 그림과 같이 이력이 하나의 줄기로 이어지게 됩니다.
이 때 A 브랜치의 내용이 'master'의 커밋된 버전들과 충돌하는 부분이 생길 수 있습니다. 그 때는 각각의 커밋에서 발생한 충돌 내용을 수정할 필요가 있습니다.
'rebase'만 하면 'master'의 위치는 그대로 유지됩니다. 'master' 브랜치의 위치를 변경하기 위해서는 'master' 브랜치에서 A 브랜치를 fast-foward(빨리감기) 병합 하면 됩니다.

토픽 브랜치에 통합 브랜치의 최신 코드를 적용할 경우에는 rebase 를 사용,
통합 브랜치에 토픽 브랜치를 불러올 경우에는 우선 rebase 를 한 후 merge



컬럼 「A successful Git branching model」- 성공적인 Git 브랜칭 모델
원문: http://nvie.com/posts/a-successful-git-branching-model/

생각 - release 브랜치에서 배포하는 사이 혹은 hotfix에서 배포하는 사이에(즉, master, develop 브랜치에 rebase 하기 전에) feature 브랜치에서 develop 브랜치로 rebase는 안하는 게 좋다.

- 메인 브랜치(Main branch)
  'master' 브랜치와 'develop' 브랜치, 이 두 종류의 브랜치를 보통 메인 브랜치로 사용
    - master : 'master' 브랜치에서는, 배포 가능한 상태만을 관리합니다. 커밋할 때에는 태그를 사용하여 배포 번호를 기록합니다.
    - develop : 'develop' 브랜치는 앞서 설명한 통합 브랜치의 역할을 하며, 평소에는 이 브랜치를 기반으로 개발을 진행합니다.
- 피처 브랜치(Feature branch) 또는 토픽 브랜치(Topic branch)
  이 브랜치는 새로운 기능 개발 및 버그 수정이 필요할 때에 'develop' 브랜치로부터 분기합니다. 굳이 공유할 필요는 없고, 각자 개발이 완료되면 'develop' 브랜치로 병합하여 다른 사람들과 공유합니다.
- 릴리스 브랜치(Release branch)
  릴리즈 브랜치에서는 버그를 수정하거나 새로운 기능을 포함한 상태로 모든 기능이 정상적으로 동작하는지 확인합니다. 릴리즈 브랜치의 이름은 관례적으로 브랜치 이름 앞에 'release-' 를 붙입니다.
  이 때, 다음 번 릴리즈를 위한 개발 작업은 'develop' 브랜치 에서 계속 진행해 나가면 됩니다. 
  릴리즈 브랜치에서는 릴리즈를 위한 최종적인 버그 수정 등의 개발을 수행합니다. 모든 준비를 마치고 배포 가능한 상태가 되면 'master' 브랜치로 병합시키고, 병합한 커밋에 릴리즈 번호 태그를 추가합니다.
  릴리즈 브랜치에서 기능을 점검하며 발견한 버그 수정 사항은 'develop' 브랜치에도 적용해 주어야 합니다. 그러므로 배포 완료 후 'develop' 브랜치에 대해서도 병합 작업을 수행합니다.
- 핫픽스 브랜치(Hotfix branch)
  배포한 버전에 긴급하게 수정을 해야 할 필요가 있을 경우, 'master' 브랜치에서 분기하는 브랜치입니다. 관례적으로 브랜치 이름 앞에 'hotfix-'를 붙입니다.